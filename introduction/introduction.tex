%!TEX root = ../thesis.tex

\chapter{Introduction}\label{chapter:introduction}

\section{Preface}\label{sec:introduction:preface}

\section{Motivation}\label{sec:introduction:motivation}

\subsection{Transactions matter}

% TODO czemu transakcje są potrzebne
Transactions are important for performing operations on different entities and ensuring consistency among them, as well as for other reasons. They simplify making changes to the model, and provide guarantees on top of which applications are built. Without transactions, all guarantees disappear, and suddenly developers have to take care of things which were taken for granted.

\subsection{Current state of transactions in Cassandra}	
Cassandra due to its distributed nature, cannot have full acid transactions, but it supports transactional behaviour with so called Lightweight Transactions (\lwt).
Transactional behaviour in \lwt is implemented by the means of the condition clause, which specifies whether statement can execute or not, and guarantees that any LWT performed for the same key obeys to the condition, since conditions are evaluated on the consistent state of the data, as if statements were executed one after the other, thus provides serializability of modifications. \lwt transaction spans only single partition, which is the clustering of the rows in the table, therefore \lwt does not support consistent modifications to many rows.


TODO example
LWT guarantees atomic modification of single partition, which is the clustering of the rows in the table, iff specified condition is met. Main guarantee however is that after a successful LWT quorum of replicas agree on given value.


for example to do only insert if that row hasn’t existed before. 

\begin{example}
\begin{lstlisting}[style=outcode,label={lst:intro:lwtInsert},caption={LWT Insert with if not exists clause}]
INSERT INTO users (user_id, name, email)  
VALUES (1, 'John', 'john@yahoo.com') 
IF NOT EXISTS
\end{lstlisting}
\end{example}

Examples of LWT:

1)

First example uses LWT to add user John with id=1 if John was not present in database. To put it differently, to insert a row to users table only if row with given key=1 didn’t exist.



\begin{example}
\begin{lstlisting}[style=outcode,label={lst:intro:lwtUpdate},caption={LWT Update with column condition}]
UPDATE balances SET balance = 2500 WHERE user_id = 1 IF balance = 2000;
\end{lstlisting}
\end{example}

Second example shows that conditions can have expressions that are evaluated during LWT. LWT will proceed further only if condition is met. Such expressions are restricted only to row that is being updated.

LWT is a tool which allows to have some consistency guarantees, but it is limited to single row. It cannot be used to have some transaction that spans two rows with conditions between them. 
To put LWT in terms of ACID, LWTs have serial isolation level, are atomic and durable. Consistency is preserved in terms of quorum, but not in terms of all nodes involved which is the case in relational world. Section \ref{sec:theory:transactions:lwt} contains more information about \lwt.

\subsection{Workarounds for no ACID}
Atomic multi-partition updates are missing in the Cassadra, but workarounds exist, and one of them is to use \lwt and a special \emph{step} column, which represents current progress of a \emph{transaction}. Although there is no transaction enforced by the database, there is a transactional code in the logic of the client, which updates \emph{step} column on each operation, and checks the condition against that column in the subsequent operation if its value matches expected step. That way the next operation succeeds only if previous succeeded. Such model puts restrictions on how user uses database and how client's logic is written. Note that even with the special flag LWTs are still restricted to a single partition.  

Multi partition transactions would remove burden of ensuring consistency using flags and would allow users to perform their operations in more natural way without additional restrictions, and changes in the logic. 
Atomic multi-partition updates would support different use cases, for example databases could properly enforce foreign keys, do secondary indexing, update materialized views. Users would also benefit, since their applications already rely on multi-partition operations, thus logic would not have to change to completely different model in order to adapt to a distributed database. 

\section{Goals}
The main goal of the thesis is to design an algorithm that provides more than \lwt and supports multi-partition transactions; moreover it has to be scalable by its design and it cannot have a single point of failure. Additionally, the algorithm should be efficient in terms of memory consumption and network usage. To verify the designed algorithm, its proof of concept implementation has to be done in the Cassandra, and tested in the cluster employing variety of experiments to be carried out. The results will be analyzed afterwards.

\section{Structure}\label{sec:introduction:structure}
The organization of the work is as follows: 
in the next chapter we will introduce concepts of distributed databases followed by transactions and different algorithms related to them, along with descriptions of the databases with main focus on the Cassandra. 
The proposed algorithm will be discussed in Chapter 3 and its experimental implementation in Chapter 4.
Chapter 5 will present tests and theoretical analysis of the algorithm.
We will recapitulate the work in Chapter 6.

\input{introduction/introduction-terms.tex}