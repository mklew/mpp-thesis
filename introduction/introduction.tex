%!TEX root = ../thesis.tex

\chapter{Introduction}\label{chapter:introduction}

\section{Preface}\label{sec:introduction:preface}

\section{Motivation}\label{sec:introduction:motivation}

\subsection{Transactions matter}

% TODO czemu transakcje sÄ… potrzebne
Transactions are important for performing operations on different entities and ensuring consistency among them, as well as for other reasons. They simplify making changes to the model, and provide guarantees on top of which applications are built. Without transactions, all guarantees disappear, and suddenly developers have to take care of things which were taken for granted.

\subsection{Current state of transactions in Cassandra}	
Cassandra due to its distributed nature, cannot have full acid transactions, but it supports transactional behaviour with so called Lightweight Transactions (\lwt).
Transactional behaviour in \lwt is implemented by the means of the condition clause, which specifies whether statement can execute or not, and guarantees that any LWT performed for the same key obeys to the condition, since conditions are evaluated on the consistent state of the data, as if statements were executed one after the other, thus provides serializability of modifications. \lwt transaction spans only single partition, which is the clustering of the rows in the table, therefore \lwt does not support consistent modifications of many rows.

Let us look at examples of \lwt. Listing \ref{lst:intro:lwtInsert} presents a transaction, which inserts the user \emph{John} only if it is not already present in the database. \lwt guarantees consistency of the insert, and guarantees that if another client performs same insert at the same time, then \emph{John} is inserted only once, by one or the other transaction.

Listing \ref{lst:intro:lwtUpdate} presents an update transaction, which executes only if the \code{balance} column has the expected value. If another transaction changes the balance to value different than expected, the former transaction will not update the balance. Note that, conditions in the \lwt \code{IF} clause can only refer to the columns in the row that is being modified, and not to different rows.

\begin{example}
\label{lst:intro:lwtInsert}
\begin{lstlisting}[style=outcode,caption={LWT Insert with if not exists clause}]
INSERT INTO users (user_id, name, email)  
VALUES (1, 'John', 'john@yahoo.com') 
IF NOT EXISTS
\end{lstlisting}
\end{example}

\begin{example}
\label{lst:intro:lwtUpdate}
\begin{lstlisting}[style=outcode,caption={LWT Update with column condition}]
UPDATE balances SET balance = 2500 WHERE user_id = 1 IF balance = 2000;
\end{lstlisting}
\end{example}


\lwt provides a subset of transactional behaviour limited to a single partition, but it still provides a transaction, only a small one. It does not support consistent, atomic updates across different rows. 

In terms of ACID, \lwt provides serial isolation level, is atomic and durable.
Consistency is preserved in terms of quorum, but not in terms of all nodes involved which is the case in relational world. Section \ref{sec:theory:transactions:lwt} contains more information about \lwt.

\subsection{Workarounds for no ACID}
Atomic multi-partition updates are missing in the Cassadra, but workarounds exist, and one of them is to use \lwt and a special \emph{step} column, which represents current progress of a \emph{transaction}. Although there is no transaction enforced by the database, there is a transactional code in the logic of the client, which updates \emph{step} column on each operation, and checks the condition against that column in the subsequent operation if its value matches expected step. That way the next operation succeeds only if previous succeeded. Such model puts restrictions on how user uses database and how client's logic is written. Note that even with the special flag LWTs are still restricted to a single partition.  

Multi partition transactions would remove burden of ensuring consistency using flags and would allow users to perform their operations in more natural way without additional restrictions, and changes in the logic. 
Atomic multi-partition updates would support different use cases, for example databases could properly enforce foreign keys, do secondary indexing, update materialized views. Users would also benefit, since their applications already rely on multi-partition operations, thus logic would not have to change to completely different model in order to adapt to a distributed database. 

\section{Goals}
The main goal of the thesis is to design an algorithm that provides more than \lwt and supports multi-partition transactions; moreover it has to be scalable by its design and it cannot have a single point of failure. Additionally, the algorithm should be efficient in terms of memory consumption and network usage. To verify the designed algorithm, its proof of concept implementation has to be done in the Cassandra, and tested in the cluster employing variety of experiments to be carried out. The results will be analyzed afterwards.

\section{Structure}\label{sec:introduction:structure}
The organization of the work is as follows: 
in the next chapter we will introduce concepts of distributed databases followed by transactions and different algorithms related to them, along with descriptions of the databases with main focus on the Cassandra. 
The proposed algorithm will be discussed in Chapter 3 and its experimental implementation in Chapter 4.
Chapter 5 will present tests and theoretical analysis of the algorithm.
We will recapitulate the work in Chapter 6.

\input{introduction/introduction-terms.tex}