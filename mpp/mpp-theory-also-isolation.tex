%!TEX root = ../thesis.tex

\section{Isolation from other transactions}
Transactions must run in isolation from each other. Transactions cannot see each other, nor anyone else can see effects of transactions before it completes with commit or rollback.

Each key's value modification done in transaction should be stored at replicas responsible for given key keeping it private for that transaction. In order to satisfy isolation requirement, \emph{private transaction storage} has to be present on each node.

Each transactional operation is executed, but instead of operating on current live data, modifications is put into private storage. Interface of the storage is presented in the listing \ref{lst:privateTransactionStorage}.

\begin{lstlisting}[language=Java,style=outcode,label={lst:privateTransactionStorage},caption={API of private transaction storage}]
PrivateTransactionStorage {
  TransactionItem addModification(transaction id, modification)

  void removeTransactionsData(transaction id)

  Collection<Modification> getModifications(transaction id)        
}

\end{lstlisting}


From perspective of algorithm it does not matter whether modifications are stored in memory or in any other way as long as modifications are accessible during transaction.

Private transaction storage also satisfies requirement of performing many operations within transaction. Each operation is stored in private storage and mapped to transaction item.


\subsection{Quorum requirements}
Each modification within transaction should be written to at least quorum of nodes responsible for modified key. Otherwise modification has to be either tried again or whole transaction needs to be rolled back. 

\subsection{Transactional operations run in isolation}
Algorithm (\ref{alg:transactionalInsert}) shows how transactional operations are performed, concretely transactional inserts. All transactional operations are executed in the same way. 
% TODO napisac algorytm
%\subsection{Algorithm for adding operations to private transaction storage}

% \begin{figure}[hbt]
%   \begin{center}
%   \setlength{\unitlength}{0.7cm}
%   \subfloat[Client's request.]{
%     INSERT INTO users (user_id, name) VALUES (1, ‘John’) within transaction id = txId
%   }\qquad
%   \subfloat[Coordinator's algorithm.]{
%     Request is received by some node in cluster that becomes coordinator C for that request
%   }\qquad
%   \subfloat[Replica's algorithm.]{
    
%   }
%   \end{center}
%   \caption{Adding operations to private transaction storage}
%   \label{fig:addToPrivateMemtable}
% \end{figure}

% 1. Clients send a request INSERT INTO users (user_id, name) VALUES (1, ‘John’) within transaction id = txId
% 2. Request is received by some node in cluster that becomes coordinator C for that request
% 3. C identifies replicas responsible
%    1. C sees that users table has key column user_id. 
%    2. It received user_id=1
%    3. C computes token using key value = 1 
%    4. C checks in topology which replicas are responsible for that token
%    5. C finds replicas
% 1. C routes request to replica nodes
% At each replica:
%    1. Modification is added to private transaction storage of transaction with id 1001
%    2. Replica replies with success
% 1. C waits until quorum responds with success
% 2. C responds to client with transaction item
% 3. Client receives transaction item and merges it to its current transaction state

\begin{algorithm}
\algblockdefx[NAME]{StartRequest}{EndRequest}%
   [1][Unknown]{\textbf{Upon receiving} \emph{#1} \textbf{request}}%
   {\textbf{end request}}

\algblockdefx[NAME]{Message}{EndMessage}%
   [1][Unknown]{\textbf{Upon receiving} \emph{#1} \textbf{message}}%
   {\textbf{end}}   

\algblockdefx[NAME]{ForEachReplica}{EndForEachReplica}%
   {\textbf{for each} \emph{replica} $\gets$ \emph{replicas}}%
   {\textbf{end}}   

  \caption{Transactional insert}
  \label{alg:transactionalInsert}
  \begin{algorithmic}
    \StartRequest[transactional insert]      
      \State $C \gets$ coordinator node of request
      \State $T \gets$ topology at coordinator node
      \State $k \gets$ key from write request
      \State $token \gets$ token computed by \Call{Hash Function}{$k$}
      \State $replicas \gets$ \Call{Find Nodes Assigned To Token}{$T$, $token$} 
      \ForEachReplica
        \State send transactional insert $message$ to $replica$
      \EndForEachReplica
      \State await responses
      \If {$quorum(responses)$} 
        \State $response \gets$ success 
      \Else
        \State transactional insert failed
        \State $response \gets$ failure 
      \EndIf
    \EndRequest    
  
  \end{algorithmic}
  
  \begin{algorithmic}
    \Message[transactional insert]
        \State $id \gets $ transaction id from $message$
        \State \Call{Add To Private Transaction Storage}{$id$, $message.insert$}
        \State respond with success message
    \EndMessage
  \end{algorithmic}
\end{algorithm}
 
 
