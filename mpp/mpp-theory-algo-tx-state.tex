%!TEX root = ../thesis.tex

\section{Representation of a transaction}
%Transaction state consists of \emph{unique id} (UUID\footnote{universal unique identifier}) and 
%A transaction state includes a \emph{unique id} (UUID\footnote{universal unique identifier}) along with 
%all the operations and data done within \transaction, thus set of \mutation{k}{v} denoted as \mutations.

%Each modification refers to \kv, where \key defines partition, thus \mutation{k}{v} is performed for a single partition. There can be many modifications done within transaction. 

%\subsection{Transaction state}
Transaction state (Definition \ref{def:transactionState}) is used to identify transaction \transaction and to trace modifications done in \transaction, where each modification is represented by \emph{transaction item} \txItem (Definition \ref{def:transactionItem}) received in a response to \mutation{k}{v}. Transaction \transaction is identified using \emph{unique id} (UUID\footnote{universal unique identifier}), which is generated by \node{i} upon request to begin transaction. 

Transaction item allows to find nodes which store the data of \transaction, since \txItem has a token and \topologyTk{\node{i}, ..., \node{k}}.
There are many concurrent transactions, therefore transaction state should use least amount of memory possible, therefore tokens are used instead of keys. Existence of a \txItem means that replicas identified by the \emph{token} store modification of the key done in \transaction. Keys are unknown to the transaction state, but keys are known to the replicas. Each replica has full information about the key and operations performed on the value associated with it. 

Transaction item includes also a table name in order to distinguish modifications associated with the same token, but in different tables. This can be extended to any other name spacing.
Token alone only directs us to nodes with modified data, but to know what has been modified, we also need names of tables. 

Transaction state has deterministic memory footprint, since it stores fixed-length tokens instead of keys with unknown size. 

\begin{definition}
  \label{def:transactionItem}
  \emph{Transaction item}, denoted as $ti$, is a pair of a token and a table name $(tk,table)$.
\end{definition}

\begin{definition}
  \label{def:transactionState}
  \emph{Transaction state}, denoted as $TS$, is a pair of a unique transaction id and set of transaction items $(id, \{ \text{\txItemi{a}, ..., \txItemi{k}} \})$.
\end{definition}

\subsubsection{Alternative structure}
Transaction state which stores keys instead of tokens provides same functionality, but varies in memory footprint, hence \mpt is applicable to \emph{key-value} databases in general, but its memory usage might not be as low as with tokens if keys have more complex type than number.
%Same functionality could be achieved storing real keys in transaction items, but then each key could have arbitrary size and same would apply to transaction state.

\subsubsection{Unique id only}
Transaction items identify nodes that own part of transaction's data. Without them we would know only an id of a transaction.
Using just an id we would need to ask each node in the cluster if it has data associated with transaction. As a corollary the algorithm would be dependent on all nodes in the cluster, thus resilience to partial failure would be lost.

\subsubsection{Updates}
Transaction state changes as transaction progresses. It has to be updated with new transaction items for each operation. Moreover, each operation should return new transaction item which can be appended to transaction state. 


% algorytm z pakietu algorithm2e
% \begin{algorithm}
% \SetKwFunction{startTx}{Begin Transaction}
% \SetKwFunction{updateOperation}{Update Operation}
% \SetKwFunction{commitTx}{CommitTransaction}
% \DontPrintSemicolon
% \KwData{$k$ key}
% \KwData{$value$ of $k$ to update in transaction}
% %\KwResult{$Gâ€™=(X,V)$ with $V\subseteq U$ such that  is an interval order.}
% \Begin{
%   $transactionState \longleftarrow BeginTransaction()$ \;
%   $transactionState \longleftarrow \startTx()$ \;
%   $id \longleftarrow transactionState.id$ \;
%   no comment here\;
%   $transactionItem \longleftarrow \updateOperation(id, k, value)$\;
%   $transactionState.addItem(transactionItem)$
%   $result \longleftarrow \commitTx(transactionState)$  
%   }
% \caption{Updating transaction state after an operation222\label{IR}}
% \end{algorithm}

% algorytm z pakietu algorithm

% \begin{algorithmic}[1]
% \Begin
% \State $sum:=0$;
% \For{i=1}{n}\Comment{sum(i)}
%    \State $sum:=sum+i$;
% \State writeln($sum$);
% \End.
% \end{algorithmic}

\begin{algorithm}
  \caption{Updating transaction state after two operations}
  \label{alg:updateTxState}
  \begin{algorithmic}  	    
    \State $TS(id, \{ \}) \gets$ \Call{Begin Transaction}{}
    \State $id \gets$ $TS.id$ unique id generated for transaction
    \State $ti_{1} \gets $ \Call{Update Operation}{id, $k_{1}$, $v_{1}$} \Comment for some key and value
    \State $TS(id, \{ ti_{1} \}) \gets$ \Call{Add Item}{$TS$, $ti_{1}$}
    \State $ti_{2} \gets $ \Call{Insert Operation}{id, $k_{2}$, $v_{2}$}
    \State $TS(id, \{ ti_{1}, ti_{2} \}) \gets$  \Call{Add Item}{$TS$, $ti_{2}$}
    \State $result \gets $ \Call{Commit Transaction}{$TS$}    
  \end{algorithmic}
\end{algorithm}

Appending transaction items is the crucial step of Algorithm \ref{alg:updateTxState}, because a client is responsible for keeping track of all performed operations within transaction. Transaction state is assumed to be source of truth about transaction, which means that is has valid information about which replicas are affected by the transaction.
Note that, client i.e. database driver has to keep track of transaction items and append them to the transaction state, but an end user of the driver is potentially unaware of transaction items.

%Nodes are unaware of modifications done at other nodes. Only client can gather all that information and keep track of it.
 %       Merging two transaction states, simply means concatenating collections of transaction items from two transactions given that transaction id is the same. In terms of functional programming, transaction state is a monoid.

