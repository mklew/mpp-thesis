%!TEX root = ../thesis.tex

\section{The outline}
Client, denoted as $c$ is an actor, which communicates to a cluster of nodes; \nodes expresses number of nodes and \node{i} refers to a node, where $i \in [1,N]$. \client begins a transaction \transaction by sending a request to any node in a cluster \clientReq{i} and receives response \nodeReqResponse{i}, which includes 
initial \emph{transaction state}, which reflects all changes done in \transaction and is defined as \emph{transaction id} and set of \emph{transaction items}. Transaction id identifies the transaction and is attached to all subsequent requests. 

%Transaction id identifies the transaction and is attached to all subsequent requests. Transaction item is a reference to operations done in \transaction.

Client \client performs two types of operations during \transaction: \emph{mutations} \mutations, as in Definition \ref{def:mutation} and select statements of \kv. All \mutation{k}{v}  performed by \client are isolated from other clients and are private to \transaction until \transaction is committed. Mutations are stored in a \emph{private transaction storage}, which is a local data structure at each \node{i}, for the duration of the transaction, whereas read operations query against current state of the database, thus transactions provide read-committed isolation level.

After each \clientReq{i} with a \mutation{k}{v} \client receives a response \nodeReqResponse{i}, which includes a transaction item referencing the \mutation{k}{v}. Client is responsible for tracing changes performed in \transaction, thus \client has to append all received transaction items to the initial transaction state.

When \client finishes its planned operations \transaction can be either committed or rolled back. To perform rollback \client performs \clientReq{i} including transaction state, and then \node{i} sends out rollback messages to other nodes \nodeMessage{i}{j,k,l,...}, identified using transaction items, which remove private data from their private transaction storage and mark \transaction as rolled back in \emph{transaction log}, which is a local data structure.

In order to commit \transaction \client performs \clientReq{i} with transaction state attached, and subsequently \node{i} becomes the coordinator of the transaction and is responsible for orchestrating distributed consensus among nodes affected by \transaction referenced by transaction items. When consensus is reached each node moves private data of \transaction from private transaction storage to the main storage and marks \transaction, as committed in transaction log. Client receives response \nodeReqResponse{i} about successfully committed transaction.

There are many concurrent transactions and some of them mutate same keys, thus concurrency control is required which gurantees that interfering transactions are not committed at the same time. Commit procedure solves this problem by grouping such transactions and performing distributed consensus round, which selects single transaction that is committed, whereas the rest is rolled back.
Commit procedure uses another local data structure \emph{transaction index}, which is responsible for identifing interfering transactions and grouping them into same consenus rounds.

\begin{definition}
  \label{def:mutation}
  \emph{Mutation} denoted as \mutation{k}{v} is an operation, such as insert, update or removal of one or more key value pairs \kv.
\end{definition}


\subsection{Brudnopis z oznaczeniami}

Node denoted as $n_i$ where $i \in $


Nowe oznaczenia:

Database consists of key-value pairs $\Omega((k_{i},v_{j}), (k_{k},v_{m}),...)$ where $k\in\mathit{K}, v\in\mathit{V}$ stored by cluster of nodes $\mathit{N}$. Node is defined, as $n_{i}\in\mathit{N}$ where $\mathit{N}$. Client of a cluster is denoted by $c_{i}\in\mathit{C}$. Changes to data are represented by \emph{mutations}, where mutation is defined by $\delta(k,v)$ where $k \in \mathit{K}, v \in \mathit{V}$.
A set of mutations is a transaction denoted, as $\Theta(\delta_{1}, \delta_{2}, ...)$. Topology is a partitioning function $\tau:\mathit{K} \mapsto \mathit{N^{RF}}$ which given $k$ returns set of replica nodes. 

\emph{Transaction state} is defined by $\Lambda(\lambda_{i}, \lambda_{j}, ...)$ where $\lambda_{i}$ is \emph{transaction item}, which is equivalent\footnote{transaction item is redefined in Chapter 4} of a key $k$.


Clients and nodes communicate by messages, where message is defined, as $\mathit{M}(n_{i}, n_{j}, \psi)$ where 
$n_{i}\in\mathit{N}\cup\mathit{C}, n_{j}\in\mathit{N}\cup\mathit{C},\{n_{i}, n_{j}\}\cap\mathit{N}\neq\emptyset$ and $\psi$ is a payload, which is one of following:
- $\mathit{begin\_transaction}()$
- $\mathit{begin\_transaction_response}(\lambda)$
- begin transaction response(ts)
- insert(k,v)
- insert response()
- update(k,v)
- delete(k)
- commit(ts)
- setup(ts)
- prepare(ts, b)
- propose(ts, b)
- commit(ts)


Client request \clientReq{2}

Node response \nodeReqResponse{2}

Node message \nodeMessage{1}{2}

Node response message \nodeMessage{2}{1}

Key \key

Key i \keyi{2}

value \kvalue

value i \kvaluei{3}

key value \kv

Mutation \mutation{k}{v}

TODO poprawa oznaczen
Transakcja to zbiór mutacji (male delty)

3 rozdział brak tokenów, brak tabeli

tokeny i tabele dopiero w implementacji.  - rozdzial 4

Rozdzial 3 najbardziej ogólnie, nic o Cassandrze.

Rozdział 4 jak to zostało zaimplementowane dla Cassandry.

Zamiast request response zdefiniować message który dzieli się na typy.
message ma źródło, cel, payload. Payloady to rozne typy

Funkcja noda to f: M -> M 
czyli funkcja ktora przeklsztalca message w message. 
Dzialanie noda jest zdefiniowane przez funkcje jaks tam bo zawsze masz request response.
f: (S, M) -> (S, M)
gdzie S to stan noda.

2.3.2 uprościć o CAP

2.2
Poprzec literaturą stwierdzenia, że RDMBS ma ACID, a NoSql nie ma.

Przedstawiać bazy relacyjne i bazy nierelacyjne
Bazy rozproszone i bazy nierozproszone.

Nie mówić o bazach relacyjnych i bazach rozproszonych

Paxos
Coordinator node Propser
Node 1,2,3 Acceptor

Figure 2.3 Paxos pokazać przypadek z drugim proposerem.

2PC, 3PC, Paxos przedstawiane z różnej perspektywy.
Porównać w każdym przypadku odporność na awarie.

Wyodrębnić zbiór aspektów który będę porównywał. 
Akapit per aspekt tak żebym móc porównać jeden z drugim.

Cechy specyficzne w pierwszym akapicie.

1 Co to jest, cechy specyficzne
2. akaip to ogólny Opis
3. Aspekt 1
4. Aspekt 2
5. Aspekt 3


